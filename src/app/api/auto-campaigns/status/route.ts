/**
 * Cron Job Status API
 * This endpoint checks the status of the auto-campaign generation cron job
 * Returns last execution time, recent campaigns, and cron configuration
 * 
 * CRON SCHEDULE:
 * - Schedule: "30 00 * * *" (00:30 AM UTC daily)
 * - IST Time: 6:00 AM IST
 * - UTC Time: 00:30 AM UTC (00:30 UTC)
 * - Time Conversion: IST = UTC + 5:30, so 6:00 AM IST = 00:30 AM UTC
 * - Example: 6:00 AM IST on Jan 2 = 00:30 AM UTC on Jan 2
 */

import { NextResponse } from "next/server"
import { admin, initFirebaseAdmin } from "@/server/firebaseAdmin"
import { authenticateRequest, createAuthErrorResponse } from "@/utils/apiAuth"

/**
 * GET /api/auto-campaigns/status
 * Returns cron job status, last execution, and recent campaigns
 * 
 * CRON CONFIGURATION (vercel.json):
 * - Path: "/api/auto-campaigns/generate?check=today&publish=true&sendWhatsApp=true"
 * - Schedule: "30 00 * * *" (00:30 AM UTC = 6:00 AM IST)
 */
export async function GET(request: Request) {
  // Authenticate request - requires admin role
  const auth = await authenticateRequest(request, "admin")
  if (!auth.success) {
    return createAuthErrorResponse(auth)
  }

  try {
    const initResult = initFirebaseAdmin("auto-campaigns-status API")
    if (!initResult.ok) {
      return NextResponse.json(
        { error: "Server not configured for admin" },
        { status: 500 }
      )
    }

    const db = admin.firestore()

    // Get cron execution logs (last 10)
    let cronLogs: any[] = []
    try {
      const cronLogsRef = db.collection("cron_logs")
        .orderBy("executedAt", "desc")
        .limit(10)
      const cronLogsSnapshot = await cronLogsRef.get()
      cronLogs = cronLogsSnapshot.docs.map(doc => {
        const data = doc.data()
        return {
          id: doc.id,
          executedAt: data.executedAt?.toDate?.()?.toISOString() || data.executedAt,
          success: data.success,
          campaignsGenerated: data.campaignsGenerated || 0,
          message: data.message,
          healthDaysChecked: data.healthDaysChecked || [],
          error: data.error,
          triggeredBy: data.triggeredBy || "unknown",
        }
      })
    } catch (error) {
      console.error("Error fetching cron logs:", error)
      // Continue without logs if query fails (e.g., missing index)
    }

    // Get last execution
    const lastExecution = cronLogs.length > 0 ? cronLogs[0] : null

    // Get recent auto-generated campaigns (last 7 days)
    let recentCampaigns: any[] = []
    try {
      const sevenDaysAgo = new Date()
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7)
      const recentCampaignsRef = db.collection("campaigns")
        .where("metadata.autoGenerated", "==", true)
        .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(sevenDaysAgo))
        .orderBy("createdAt", "desc")
        .limit(10)
      const recentCampaignsSnapshot = await recentCampaignsRef.get()
      recentCampaigns = recentCampaignsSnapshot.docs.map(doc => {
        const data = doc.data()
        return {
          id: doc.id,
          title: data.title,
          healthDay: data.metadata?.healthAwarenessDay,
          healthDayDate: data.metadata?.healthDayDate,
          createdAt: data.createdAt?.toDate?.()?.toISOString() || data.createdAt,
          status: data.status,
        }
      })
    } catch (error) {
      console.error("Error fetching recent campaigns:", error)
      // Continue without recent campaigns if query fails (e.g., missing index)
    }

    // Calculate next cron execution
    // CRON SCHEDULE: "30 00 * * *" (00:30 AM UTC = 6:00 AM IST)
    // IST is UTC+5:30, so 6:00 AM IST = 00:30 AM UTC (00:30 UTC)
    // Example: 6:00 AM IST on Jan 2 = 00:30 AM UTC on Jan 2
    const now = new Date()
    const istOffset = 5.5 * 60 * 60 * 1000 // IST offset in milliseconds (5 hours 30 minutes)
    
    // Get current time in UTC
    const utcNow = new Date(now.getTime() + (now.getTimezoneOffset() * 60 * 1000))
    
    // Calculate target time: 6:00 AM IST = 00:30 AM UTC (00:30 UTC)
    // CRON SCHEDULE: "30 00 * * *" runs at 00:30 AM UTC (00:30 UTC) which is 6:00 AM IST
    // Create a date for today at 00:30 AM UTC (hour 00, minute 30)
    const nextCronUTC = new Date(utcNow)
    nextCronUTC.setUTCHours(0, 30, 0, 0) // Set to 00:30 AM UTC (00:30 UTC) = 6:00 AM IST
    
    // If today's 00:30 AM UTC has already passed, set for tomorrow
    if (nextCronUTC.getTime() <= utcNow.getTime()) {
      nextCronUTC.setUTCDate(nextCronUTC.getUTCDate() + 1)
    }

    // Get today's date in IST for health awareness day lookup
    // IST is UTC+5:30, so we add the offset to get IST time
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000)
    const istTime = new Date(utcTime + istOffset)
    // Get date components in IST (month and day)
    const istMonth = istTime.getUTCMonth() + 1 // getUTCMonth returns 0-11
    const istDay = istTime.getUTCDate()
    const todayDateString = `${String(istMonth).padStart(2, '0')}-${String(istDay).padStart(2, '0')}`
    
    // For display purposes, also create a date object for today at midnight IST
    const todayIST = new Date(istTime)
    todayIST.setUTCHours(0, 0, 0, 0)

    // Check if cron is configured (check vercel.json by checking if endpoint exists)
    const cronConfigured = true // Assume configured if endpoint exists

    // Get today's health awareness days (uses IST internally)
    const { getHealthAwarenessDaysForToday } = await import("@/server/healthAwarenessDays")
    const todayHealthDays = getHealthAwarenessDaysForToday()

    return NextResponse.json({
      success: true,
      cron: {
        configured: cronConfigured,
        schedule: "30 00 * * *", // Daily at 00:30 AM UTC (6:00 AM IST)
        scheduleUTC: "30 00 * * *", // Actual cron schedule (UTC) - 00:30 AM UTC = 6:00 AM IST
        scheduleDisplay: "6:00 AM IST (00:30 AM UTC)", // Human-readable display
        nextExecution: nextCronUTC.toISOString(),
        nextExecutionFormatted: new Date(nextCronUTC).toLocaleString("en-IN", {
          timeZone: "Asia/Kolkata",
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          timeZoneName: "short",
        }),
      },
      lastExecution: lastExecution,
      executionHistory: cronLogs,
      recentCampaigns: recentCampaigns,
      today: {
        date: todayDateString,
        dateIST: `${String(todayIST.getUTCMonth() + 1).padStart(2, '0')}/${String(todayIST.getUTCDate()).padStart(2, '0')}/${todayIST.getUTCFullYear()}`,
        healthDaysCount: todayHealthDays.length,
        healthDays: todayHealthDays.map(d => ({
          name: d.name,
          date: d.date,
          priority: d.priority,
        })),
      },
      status: lastExecution
        ? lastExecution.success
          ? "healthy"
          : "error"
        : "unknown",
    })
  } catch (error: any) {
    console.error("Error checking cron status:", error)
    return NextResponse.json(
      {
        success: false,
        error: error?.message || "Failed to check cron status",
      },
      { status: 500 }
    )
  }
}

