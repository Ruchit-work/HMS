

export const dynamic = 'force-dynamic' // Prevent caching for cron jobs
export const revalidate = 0

import { NextResponse } from "next/server"
import { admin, initFirebaseAdmin } from "@/server/firebaseAdmin"
import {
  getHealthAwarenessDaysForToday,
  getHealthAwarenessDaysForTomorrow,
} from "@/server/healthAwarenessDays"
import { generateAdvertisements } from "@/server/groqAdvertisementGenerator"
import { sendWhatsAppNotification } from "@/server/whatsapp"
import { slugify } from "@/utils/campaigns/campaigns"
import type { Firestore } from "firebase-admin/firestore"
import { authenticateRequest, createAuthErrorResponse } from "@/utils/firebase/apiAuth"
import { getAllActiveHospitals, getHospitalCollectionPath } from "@/utils/firebase/serverHospitalQueries"

async function cleanupExpiredAutoCampaigns(db: Firestore) {
  const now = new Date()
  let deleted = 0

  try {
    const snapshot = await db
      .collection("campaigns")
      .where("metadata.autoGenerated", "==", true)
      .get()

    for (const doc of snapshot.docs) {
      const data = doc.data()
      const endAt = data.endAt
      const endAtDate =
        typeof endAt?.toDate === "function"
          ? endAt.toDate()
          : endAt
          ? new Date(endAt)
          : null
      if (endAtDate && endAtDate.getTime() <= now.getTime()) {
        await doc.ref.delete()
        deleted += 1
      }
    }
  } catch {
  }

  return deleted
}


function isCronTriggerRequest(request: Request): boolean {
  if (request.headers.get("x-vercel-cron") !== null) return true
  const cronSecret = process.env.CRON_SECRET
  if (!cronSecret) return false
  const authHeader = request.headers.get("authorization")
  if (authHeader?.startsWith("Bearer ") && authHeader.slice(7).trim() === cronSecret) return true
  const secretHeader = request.headers.get("x-cron-secret")
  if (secretHeader === cronSecret) return true
  return false
}

export async function GET(request: Request) {
  const isCronTrigger = isCronTriggerRequest(request)
  let adminHospitalId: string | null = null
  
  if (!isCronTrigger) {
    const auth = await authenticateRequest(request, "admin")
    if (!auth.success) {
      return createAuthErrorResponse(auth)
    }
    if (auth.user?.uid) {
      const { getUserActiveHospitalId } = await import("@/utils/firebase/serverHospitalQueries")
      adminHospitalId = await getUserActiveHospitalId(auth.user.uid)
    }
  }

  const startTime = Date.now()
  const triggerSource = isCronTrigger ? "cron" : "manual"
  
  try {
    const initResult = initFirebaseAdmin("auto-campaigns-generate API")
    if (!initResult.ok) {
      return NextResponse.json(
        { error: "Server not configured for admin" },
        { status: 500 }
      )
    }

    const url = new URL(request.url)
    const checkParam = url.searchParams.get("check") || "today"
    const publishParam = url.searchParams.get("publish") !== "false"
    const sendWhatsAppParam = url.searchParams.get("sendWhatsApp") === "true" || 
                             (url.searchParams.get("sendWhatsApp") !== "false" && isCronTrigger)
    const testMode = url.searchParams.get("test") === "true"
    const randomMode = url.searchParams.get("random") === "true"
    let healthDays =
      checkParam === "tomorrow"
        ? getHealthAwarenessDaysForTomorrow()
        : getHealthAwarenessDaysForToday()

    if (randomMode && checkParam === "today") {
      const now = new Date()
      const istOffset = 5.5 * 60 * 60 * 1000
      const utcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000)
      const istTime = new Date(utcTime + istOffset)
      const month = String(istTime.getUTCMonth() + 1).padStart(2, '0')
      const day = String(istTime.getUTCDate()).padStart(2, '0')
      const randomDate = `${month}-${day}`
      
      // Random health topics for variety
      const randomTopics = [
        { name: "Heart Health Awareness Day", keywords: ["heart", "cardiac", "cardiovascular", "bp"], specialization: ["Cardiology"] },
        { name: "Mental Wellness Day", keywords: ["mental", "wellness", "stress", "anxiety"], specialization: ["Psychiatry"] },
        { name: "Diabetes Prevention Day", keywords: ["diabetes", "sugar", "blood glucose", "prevention"], specialization: ["Endocrinology"] },
        { name: "Women's Health Day", keywords: ["women", "gynecology", "reproductive", "health"], specialization: ["Gynecology"] },
        { name: "Child Health Day", keywords: ["children", "pediatrics", "vaccination", "growth"], specialization: ["Pediatrics"] },
        { name: "Eye Care Awareness Day", keywords: ["eye", "vision", "ophthalmology", "sight"], specialization: ["Ophthalmology"] },
        { name: "Bone Health Day", keywords: ["bone", "orthopedic", "fracture", "calcium"], specialization: ["Orthopedics"] },
        { name: "Skin Health Day", keywords: ["skin", "dermatology", "acne", "dermatitis"], specialization: ["Dermatology"] },
        { name: "Digestive Health Day", keywords: ["digestive", "gastroenterology", "stomach", "gut"], specialization: ["Gastroenterology"] },
        { name: "Respiratory Health Day", keywords: ["respiratory", "lungs", "breathing", "asthma"], specialization: ["Pulmonology"] },
      ]
      
      const randomTopic = randomTopics[Math.floor(Math.random() * randomTopics.length)]
      
      healthDays = [{
        name: randomTopic.name,
        date: randomDate,
        description: `A special awareness day focused on ${randomTopic.name.toLowerCase()}. Take care of your health and schedule a checkup today.`,
        keywords: randomTopic.keywords,
        targetAudience: "all",
        priority: Math.floor(Math.random() * 3) + 3, // Priority 3-5
        specialization: randomTopic.specialization,
      }]
    } else if (testMode && healthDays.length === 0 && checkParam === "today") {
      const now = new Date()
      const istOffset = 5.5 * 60 * 60 * 1000
      const utcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000)
      const istTime = new Date(utcTime + istOffset)
      const month = String(istTime.getUTCMonth() + 1).padStart(2, '0')
      const day = String(istTime.getUTCDate()).padStart(2, '0')
      const testDate = `${month}-${day}`
      
      healthDays = [{
        name: "Test Health Awareness Day",
        date: testDate,
        description: "This is a test awareness day created for testing the auto-campaign system. It will be automatically generated when test mode is enabled.",
        keywords: ["test", "health", "awareness", "testing"],
        targetAudience: "all",
        priority: 5,
        specialization: ["General Physician"],
      }]
    }

    if (healthDays.length === 0) {
      const message = `No health awareness days found for ${checkParam}`
      let autoExpired = 0
      try {
        const db = admin.firestore()
        autoExpired = await cleanupExpiredAutoCampaigns(db)
      } catch {
      }
      
      return NextResponse.json({
        success: true,
        message,
        campaignsGenerated: 0,
        campaigns: [],
        triggeredBy: triggerSource,
        autoCampaignsDeleted: autoExpired,
      })
    }

    const istOffset = 5.5 * 60 * 60 * 1000
    const now = new Date()
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000)
    const istTime = new Date(utcTime + istOffset)
    
    const targetIST = checkParam === "tomorrow"
      ? new Date(istTime.getTime() + 24 * 60 * 60 * 1000)
      : new Date(istTime)
    
    targetIST.setUTCHours(0, 0, 0, 0)
    targetIST.setUTCMinutes(0)
    targetIST.setUTCSeconds(0)
    targetIST.setUTCMilliseconds(0)
    
    const targetDateUTC = new Date(targetIST.getTime() - istOffset)
    const hospitalName = process.env.HOSPITAL_NAME || "Harmony Medical Services"
    const advertisements = await generateAdvertisements(healthDays, hospitalName)

    const db = admin.firestore()
    const campaignsCreated: Array<{
      id: string
      title: string
      healthDay: string
      status: string
      hospitalId: string
    }> = []

    let hospitalsToProcess: Array<{ id: string; name: string }> = []
    if (isCronTrigger) {
      hospitalsToProcess = await getAllActiveHospitals()
    } else if (adminHospitalId) {
      const hospitalDoc = await db.collection('hospitals').doc(adminHospitalId).get()
      if (hospitalDoc.exists) {
        hospitalsToProcess = [{
          id: adminHospitalId,
          name: hospitalDoc.data()?.name || 'Unknown Hospital'
        }]
      } else {
        return NextResponse.json({
          success: false,
          error: "Admin's hospital not found",
          campaignsGenerated: 0,
        }, { status: 400 })
      }
    } else {
      return NextResponse.json({
        success: false,
        error: "No hospital associated with admin account",
        campaignsGenerated: 0,
      }, { status: 400 })
    }

    for (const hospital of hospitalsToProcess) {
      for (const healthDay of healthDays) {
      const advertisement = advertisements.get(healthDay.name)

      if (!advertisement) {
        continue
      }

      try {
        const targetISTMonth = targetIST.getUTCMonth() + 1
        const targetISTDay = targetIST.getUTCDate()
        const targetDateStringIST = `${String(targetISTMonth).padStart(2, '0')}-${String(targetISTDay).padStart(2, '0')}`
        
        let alreadyExists = false
        try {
          const existingCampaigns = await db
            .collection("campaigns")
            .where("metadata.healthDayDate", "==", healthDay.date)
            .where("metadata.autoGenerated", "==", true)
            .where("hospitalId", "==", hospital.id)
            .get()

          existingCampaigns.forEach((doc) => {
            const data = doc.data()
            if (data.startAt) {
              const startAtUTC = data.startAt?.toDate?.() || new Date(data.startAt)
              const startAtUTC_Time = startAtUTC.getTime() + (startAtUTC.getTimezoneOffset() * 60 * 1000)
              const startAtIST = new Date(startAtUTC_Time + istOffset)
              const startISTMonth = startAtIST.getUTCMonth() + 1
              const startISTDay = startAtIST.getUTCDate()
              const startDateStringIST = `${String(startISTMonth).padStart(2, '0')}-${String(startISTDay).padStart(2, '0')}`
              
              if (startDateStringIST === targetDateStringIST) {
                alreadyExists = true
              }
            }
          })
        } catch {
          alreadyExists = false
        }

        // Store advertisement data for WhatsApp sending (even if campaign already exists)
        let whatsAppAdvertisement = advertisement
        let whatsAppCampaignTitle = advertisement.title
        let campaignRef: admin.firestore.DocumentReference | null = null

        if (alreadyExists) {
          if (sendWhatsAppParam && checkParam === "today") {
            try {
              // Try to get existing campaign data for WhatsApp message (for this hospital)
              const existingCampaignsList = await db
                .collection("campaigns")
                .where("metadata.healthDayDate", "==", healthDay.date)
                .where("metadata.autoGenerated", "==", true)
                .where("hospitalId", "==", hospital.id)
                .limit(1)
                .get()
              
              if (!existingCampaignsList.empty) {
                const existingCampaignDoc = existingCampaignsList.docs[0]
                campaignRef = existingCampaignsList.docs[0].ref
                const existingCampaign = existingCampaignDoc.data()
                whatsAppCampaignTitle = existingCampaign.title || advertisement.title
                // Use existing campaign's content if available, otherwise use generated advertisement
                if (existingCampaign.content) {
                  // Extract plain text from HTML content for WhatsApp
                  const plainText = existingCampaign.content
                    .replace(/<[^>]*>/g, "")
                    .replace(/&nbsp;/g, " ")
                    .replace(/&amp;/g, "&")
                    .replace(/&lt;/g, "<")
                    .replace(/&gt;/g, ">")
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'")
                    .trim()
                  
                  // Use existing campaign's short message if available, otherwise use generated
                  whatsAppAdvertisement = {
                    ...advertisement,
                    title: whatsAppCampaignTitle,
                    shortMessage: existingCampaign.metadata?.shortMessage || plainText.substring(0, 200) || advertisement.shortMessage,
                    ctaHref: existingCampaign.ctaHref || advertisement.ctaHref,
                    ctaText: existingCampaign.ctaText || advertisement.ctaText,
                  }
                }
              }
            } catch {
            }
          } else {
            continue
          }
        } else {
          const expiryDateUTC = new Date(targetDateUTC.getTime() + 24 * 60 * 60 * 1000)
          const expiryDateIST = new Date(expiryDateUTC.getTime() + istOffset)

          const campaignData = {
            title: advertisement.title,
            slug: slugify(healthDay.name),
            content: advertisement.content,
            imageUrl: "",
            ctaText: advertisement.ctaText,
            ctaHref: advertisement.ctaHref,
            audience: healthDay.targetAudience,
            status: publishParam ? "published" : "draft",
            priority: healthDay.priority,
            startAt: admin.firestore.Timestamp.fromDate(targetDateUTC),
            endAt: admin.firestore.Timestamp.fromDate(expiryDateUTC),
            createdBy: "auto-campaign-system",
            updatedBy: "auto-campaign-system",
            hospitalId: hospital.id,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            metadata: {
              healthAwarenessDay: healthDay.name,
              healthDayDate: healthDay.date,
              autoGenerated: true,
              generatedAt: new Date().toISOString(),
              targetDate: targetIST.toISOString(),
              targetDateUTC: targetDateUTC.toISOString(),
              shortMessage: advertisement.shortMessage,
              autoExpiresAtUTC: expiryDateUTC.toISOString(),
              autoExpiresAtIST: expiryDateIST.toISOString(),
            },
          }

          campaignRef = await db.collection("campaigns").add(campaignData)

          campaignsCreated.push({
            id: campaignRef.id,
            title: advertisement.title,
            healthDay: healthDay.name,
            status: campaignData.status,
            hospitalId: hospital.id,
          })
        }


        // Only send notifications if the campaign is for today (not tomorrow)
        if (sendWhatsAppParam && whatsAppAdvertisement.shortMessage && checkParam === "today") {
          try {
            // Get base URL for building full links
            // Try VERCEL_URL first (for Vercel deployments), then NEXT_PUBLIC_BASE_URL, then request origin
            const requestUrl = new URL(request.url)
            const baseUrl = 
              process.env.VERCEL_URL 
                ? `https://${process.env.VERCEL_URL}`
                : process.env.NEXT_PUBLIC_BASE_URL 
                ? process.env.NEXT_PUBLIC_BASE_URL
                : requestUrl.origin || request.headers.get("origin") || "https://your-domain.com"
            
            let appointmentUrl = whatsAppAdvertisement.ctaHref || "/patient-dashboard/book-appointment"
            if (!appointmentUrl.startsWith("http")) {
              const normalizedPath = (appointmentUrl.startsWith("/") ? appointmentUrl : `/${appointmentUrl}`)
                .replace(/\/{2,}/g, "/")
                .replace("/patient-dashboard/patient-dashboard/", "/patient-dashboard/")

              let origin = baseUrl
              try {
                origin = new URL(baseUrl).origin
              } catch {
                // baseUrl might already be an origin string; leave as-is
              }

              appointmentUrl = `${origin}${normalizedPath}`
            }
            
            const whatsAppContentSid = process.env.WHATSAPP_CONTENT_SID || "HX42269b25d07c88206e6f00f2bfdddbd4"
            
            const baseContentVariables: Record<string, string> = {
              "2": whatsAppCampaignTitle,
              "3": whatsAppAdvertisement.shortMessage,
              "4": appointmentUrl,
              "6": appointmentUrl,
            }
            const whatsAppMessage = `üè• *${whatsAppCampaignTitle}*

${whatsAppAdvertisement.shortMessage}

To book an appointment or learn more, please use the options below:`

            const messageWithLink = `${whatsAppMessage}\n\nBook Appointment: ${appointmentUrl}`

            const whatsAppPromises: Promise<{ success: boolean; phone: string; error?: string }>[] = []
            try {
              // Try to get active patients first, but also check for patients without status field
              let patientsSnapshot: FirebaseFirestore.QuerySnapshot<FirebaseFirestore.DocumentData>
              try {
                patientsSnapshot = await db
                  .collection(getHospitalCollectionPath(hospital.id, "patients"))
                  .where("status", "in", ["active"])
                  .get()
              } catch {
                // If index doesn't exist, try getting all patients and filter
                const allPatients = await db
                  .collection(getHospitalCollectionPath(hospital.id, "patients"))
                  .get()
                // Filter for active patients or patients without status (default to active)
                const filteredDocs = allPatients.docs.filter(doc => {
                  const data = doc.data()
                  return !data.status || data.status === "active"
                })
                // Create a QuerySnapshot-like object
                patientsSnapshot = {
                  size: filteredDocs.length,
                  forEach: (callback: (doc: FirebaseFirestore.QueryDocumentSnapshot<FirebaseFirestore.DocumentData>) => void) => {
                    filteredDocs.forEach((doc) => {
                      callback(doc)
                    })
                  },
                  docs: filteredDocs,
                  empty: filteredDocs.length === 0,
                  query: allPatients.query,
                  readTime: allPatients.readTime,
                  docChanges: () => [],
                  isEqual: allPatients.isEqual.bind(allPatients),
                } as FirebaseFirestore.QuerySnapshot<FirebaseFirestore.DocumentData>
              }

              patientsSnapshot.forEach((doc) => {
                const patientData = doc.data()
                const phone = patientData.phone || patientData.phoneNumber || patientData.contact
                const patientName = patientData.name || patientData.fullName || `${patientData.firstName || ""} ${patientData.lastName || ""}`.trim() || "Patient"
                const patientId = doc.id

                if (phone && phone.trim() !== "") {
                  const bookingParams = new URLSearchParams({
                    phone: phone.replace(/[^\d+]/g, ""),
                    patientId: patientId,
                  })
                  const bookingUrl = `${appointmentUrl}?${bookingParams.toString()}`

                  const contentVariables = {
                    ...baseContentVariables,
                    "1": patientName,
                    "4": bookingUrl,
                    "6": bookingUrl,
                  }
                  
                  whatsAppPromises.push(
                    sendWhatsAppNotification({
                      to: phone,
                      message: messageWithLink.replace(appointmentUrl, bookingUrl),
                      contentSid: whatsAppContentSid,
                      contentVariables: contentVariables,
                    })
                      .then((result) => {
                        if (!result.success) {
                          // WhatsApp send failed
                        } else {
                          // WhatsApp sent successfully
                        }
                        return { success: result.success, phone: phone.substring(0, 3) + "***", error: result.error }
                      })
                      .catch((error) => {
                        // Error sending WhatsApp
                        return { success: false, phone: phone.substring(0, 3) + "***", error: error instanceof Error ? error.message : String(error) }
                      })
                  )
                } else {
                  // Patient has no phone number, skipping
                }
              })
            } catch {
            }

            // Await all WhatsApp promises and log results
            if (whatsAppPromises.length > 0) {
              try {
                const results = await Promise.all(whatsAppPromises)
                const failureCount = results.filter(r => !r.success).length
                if (failureCount > 0) {
                  // Some WhatsApp messages failed to send
                }
              } catch {
              }
            } else {
            }
          } catch {
          }
        }
      } catch {
        // Continue with other campaigns even if one fails
      }
    } // End of health day loop
    } // End of hospital loop

    const autoExpired = await cleanupExpiredAutoCampaigns(db)

    const executionTimeMs = Date.now() - startTime
    const executionLog = {
      executedAt: admin.firestore.FieldValue.serverTimestamp(),
      checkParam,
      success: true,
      campaignsGenerated: campaignsCreated.length,
      campaigns: campaignsCreated,
      healthDaysChecked: healthDays.map((d) => d.name),
      message: `Generated ${campaignsCreated.length} campaigns for ${checkParam}`,
      triggeredBy: triggerSource,
      executionTimeMs,
      autoCampaignsDeleted: autoExpired,
    }

    try {
      await db.collection("cron_logs").add(executionLog)
    } catch {
    }

    return NextResponse.json({
      success: true,
      message: `Generated ${campaignsCreated.length} campaigns for ${checkParam}`,
      campaignsGenerated: campaignsCreated.length,
      campaigns: campaignsCreated,
      healthDaysChecked: healthDays.map((d) => d.name),
      triggeredBy: triggerSource,
      executionTimeMs: Date.now() - startTime,
      autoCampaignsDeleted: autoExpired,
    })
  } catch (error: any) {
    // Log failed execution to Firestore
    try {
      const initResult = initFirebaseAdmin("auto-campaigns-generate API (error logging)")
      if (initResult.ok) {
        const db = admin.firestore()
        const url = new URL(request.url)
        const checkParam = url.searchParams.get("check") || "today"
        const isCronTrigger = request.headers.get("x-vercel-cron") !== null
        const triggerSource = isCronTrigger ? "cron" : "manual"
        
        await db.collection("cron_logs").add({
          executedAt: admin.firestore.FieldValue.serverTimestamp(),
          checkParam,
          success: false,
          campaignsGenerated: 0,
          error: error?.message || "Failed to generate campaigns",
          triggeredBy: triggerSource,
          executionTimeMs: Date.now() - startTime,
        })
        
      }
    } catch {
      // Don't fail the request if logging fails
    }

    return NextResponse.json(
      {
        success: false,
        error: error?.message || "Failed to generate campaigns",
      },
      { status: 500 }
    )
  }
}

/**
 * POST /api/auto-campaigns/generate
 * Body: { check?: "today" | "tomorrow", publish?: boolean, sendWhatsApp?: boolean }
 */
export async function POST(request: Request) {
  try {
    const body = await request.json().catch(() => ({}))
    const check = body.check || "today"
    const publish = body.publish !== false
    const sendWhatsApp = body.sendWhatsApp === true

    // Create a new request URL with query params
    const url = new URL(request.url)
    url.searchParams.set("check", check)
    url.searchParams.set("publish", String(publish))
    url.searchParams.set("sendWhatsApp", String(sendWhatsApp))

    // Call GET handler with modified URL
    return GET(new Request(url.toString()))
  } catch (error: any) {
    return NextResponse.json(
      {
        success: false,
        error: error?.message || "Failed to generate campaigns",
      },
      { status: 500 }
    )
  }
}

