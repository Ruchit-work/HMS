/**
 * Auto Campaign Generation API
 * This endpoint generates and publishes campaigns automatically based on health awareness days
 * Can be called manually or via cron job
 */

import { NextResponse } from "next/server"
import admin from "firebase-admin"
import {
  getHealthAwarenessDaysForToday,
  getHealthAwarenessDaysForTomorrow,
} from "@/server/healthAwarenessDays"
import { generateAdvertisements } from "@/server/groqAdvertisementGenerator"
import { sendWhatsAppNotification } from "@/server/whatsapp"
import { slugify } from "@/utils/campaigns"

function initAdmin() {
  if (!admin.apps.length) {
    const projectId = process.env.FIREBASE_PROJECT_ID
    const clientEmail = process.env.FIREBASE_CLIENT_EMAIL
    let privateKey = process.env.FIREBASE_PRIVATE_KEY

    if (privateKey && privateKey.startsWith('"') && privateKey.endsWith('"')) {
      privateKey = privateKey.slice(1, -1)
    }
    if (privateKey) {
      privateKey = privateKey.replace(/\\n/g, "\n")
    }

    if (!projectId || !clientEmail || !privateKey) {
      console.error("Firebase Admin env vars missing for auto-campaigns API.")
      return false
    }

    admin.initializeApp({
      credential: admin.credential.cert({ projectId, clientEmail, privateKey }),
    })
  }
  return true
}

/**
 * GET /api/auto-campaigns/generate
 * Query params:
 * - check: "today" | "tomorrow" (default: "today")
 * - publish: "true" | "false" (default: "true")
 * - sendWhatsApp: "true" | "false" (default: "false")
 */
export async function GET(request: Request) {
  try {
    const ok = initAdmin()
    if (!ok) {
      return NextResponse.json(
        { error: "Server not configured for admin" },
        { status: 500 }
      )
    }

    const url = new URL(request.url)
    const checkParam = url.searchParams.get("check") || "today"
    const publishParam = url.searchParams.get("publish") !== "false"
    const sendWhatsAppParam = url.searchParams.get("sendWhatsApp") === "true"

    // Get health awareness days based on check parameter
    const healthDays =
      checkParam === "tomorrow"
        ? getHealthAwarenessDaysForTomorrow()
        : getHealthAwarenessDaysForToday()

    if (healthDays.length === 0) {
      return NextResponse.json({
        success: true,
        message: `No health awareness days found for ${checkParam}`,
        campaignsGenerated: 0,
        campaigns: [],
      })
    }

    // Determine the target date for campaigns (in IST)
    // IST is UTC+5:30, so midnight IST = 18:30 UTC previous day
    const istOffset = 5.5 * 60 * 60 * 1000 // IST offset in milliseconds
    const now = new Date()
    // Get current UTC time
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000)
    // Get current IST time
    const istTime = new Date(utcTime + istOffset)
    
    // Calculate target date (today or tomorrow in IST)
    const targetIST = checkParam === "tomorrow"
      ? new Date(istTime.getTime() + 24 * 60 * 60 * 1000) // Tomorrow in IST
      : new Date(istTime) // Today in IST
    
    // Set to midnight IST (00:00 IST)
    targetIST.setUTCHours(0, 0, 0, 0)
    targetIST.setUTCMinutes(0)
    targetIST.setUTCSeconds(0)
    targetIST.setUTCMilliseconds(0)
    
    // Convert IST midnight to UTC for Firestore storage
    // IST midnight = 18:30 UTC previous day
    const targetDateUTC = new Date(targetIST.getTime() - istOffset)

    // Generate advertisements using Groq API
    const hospitalName = process.env.HOSPITAL_NAME || "Harmony Medical Services"
    const advertisements = await generateAdvertisements(healthDays, hospitalName)

    const db = admin.firestore()
    const campaignsCreated: Array<{
      id: string
      title: string
      healthDay: string
      status: string
    }> = []

    // Create and publish campaigns
    for (const healthDay of healthDays) {
      const advertisement = advertisements.get(healthDay.name)

      if (!advertisement) {
        console.error(`Failed to generate advertisement for ${healthDay.name}`)
        continue
      }

      try {
        // Check if campaign already exists for this health day
        // Check by metadata.healthDayDate to avoid duplicates for the same awareness day
        const existingCampaigns = await db
          .collection("campaigns")
          .where("metadata.healthDayDate", "==", healthDay.date)
          .where("metadata.autoGenerated", "==", true)
          .get()

        // Check if we already created a campaign for this health day date (compare in IST)
        let alreadyExists = false
        const targetISTMonth = targetIST.getUTCMonth() + 1
        const targetISTDay = targetIST.getUTCDate()
        const targetDateStringIST = `${String(targetISTMonth).padStart(2, '0')}-${String(targetISTDay).padStart(2, '0')}`
        
        existingCampaigns.forEach((doc) => {
          const data = doc.data()
          // Check if campaign exists for the target date (compare in IST)
          const startAtUTC = data.startAt?.toDate?.() || new Date(data.startAt)
          // Convert UTC to IST for comparison
          const startAtUTC_Time = startAtUTC.getTime() + (startAtUTC.getTimezoneOffset() * 60 * 1000)
          const startAtIST = new Date(startAtUTC_Time + istOffset)
          const startISTMonth = startAtIST.getUTCMonth() + 1
          const startISTDay = startAtIST.getUTCDate()
          const startDateStringIST = `${String(startISTMonth).padStart(2, '0')}-${String(startISTDay).padStart(2, '0')}`
          
          if (startDateStringIST === targetDateStringIST) {
            alreadyExists = true
          }
        })

        if (alreadyExists) {
          console.log(
            `Campaign for ${healthDay.name} already exists for ${checkParam}, skipping...`
          )
          continue
        }

        // Create campaign document
        const campaignData = {
          title: advertisement.title,
          slug: slugify(healthDay.name),
          content: advertisement.content,
          imageUrl: "", // Can be enhanced later to generate or fetch images
          ctaText: advertisement.ctaText,
          ctaHref: advertisement.ctaHref,
          audience: healthDay.targetAudience,
          status: publishParam ? "published" : "draft",
          priority: healthDay.priority,
          startAt: admin.firestore.Timestamp.fromDate(targetDateUTC),
          endAt: null, // Campaign doesn't expire by default
          createdBy: "auto-campaign-system",
          updatedBy: "auto-campaign-system",
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          metadata: {
            healthAwarenessDay: healthDay.name,
            healthDayDate: healthDay.date,
            autoGenerated: true,
            generatedAt: new Date().toISOString(),
            targetDate: targetIST.toISOString(), // Target date in IST
            targetDateUTC: targetDateUTC.toISOString(), // Target date in UTC (for Firestore)
          },
        }

        const campaignRef = await db.collection("campaigns").add(campaignData)

        campaignsCreated.push({
          id: campaignRef.id,
          title: advertisement.title,
          healthDay: healthDay.name,
          status: campaignData.status,
        })

        // Send WhatsApp notifications if enabled
        // Only send notifications if the campaign is for today (not tomorrow)
        if (sendWhatsAppParam && advertisement.shortMessage && checkParam === "today") {
          try {
            // Get all active patients with phone numbers
            const patientsSnapshot = await db
              .collection("patients")
              .where("status", "in", ["active"])
              .get()

            const whatsAppPromises: Promise<void>[] = []

            patientsSnapshot.forEach((doc) => {
              const patientData = doc.data()
              const phone = patientData.phone || patientData.phoneNumber || patientData.contact

              if (phone && phone.trim() !== "") {
                whatsAppPromises.push(
                  sendWhatsAppNotification({
                    to: phone,
                    message: advertisement.shortMessage || advertisement.title,
                  })
                    .then((result) => {
                      if (!result.success) {
                        console.error(
                          `Failed to send WhatsApp to ${phone}:`,
                          result.error
                        )
                      }
                    })
                    .catch((error) => {
                      console.error(`Error sending WhatsApp to ${phone}:`, error)
                    })
                )
              }
            })

            // Send WhatsApp messages in parallel (but don't wait for all to complete)
            Promise.all(whatsAppPromises).catch((error) => {
              console.error("Error sending WhatsApp notifications:", error)
            })

            console.log(
              `Queued WhatsApp notifications for ${whatsAppPromises.length} patients`
            )
          } catch (error) {
            console.error("Error sending WhatsApp notifications:", error)
            // Don't fail the entire request if WhatsApp fails
          }
        } else if (sendWhatsAppParam && checkParam === "tomorrow") {
          console.log(
            `WhatsApp notifications will be sent tomorrow when campaigns go live for ${healthDay.name}`
          )
        }

        console.log(
          `Created campaign "${advertisement.title}" for ${healthDay.name}`
        )
      } catch (error) {
        console.error(
          `Error creating campaign for ${healthDay.name}:`,
          error
        )
        // Continue with other campaigns even if one fails
      }
    }

    // Log cron execution to Firestore
    const executionLog = {
      executedAt: admin.firestore.FieldValue.serverTimestamp(),
      checkParam,
      success: true,
      campaignsGenerated: campaignsCreated.length,
      campaigns: campaignsCreated,
      healthDaysChecked: healthDays.map((d) => d.name),
      message: `Generated ${campaignsCreated.length} campaigns for ${checkParam}`,
      triggeredBy: request.headers.get("x-vercel-cron") ? "cron" : "manual",
    }

    try {
      await db.collection("cron_logs").add(executionLog)
    } catch (logError) {
      console.error("Error logging cron execution:", logError)
      // Don't fail the request if logging fails
    }

    return NextResponse.json({
      success: true,
      message: `Generated ${campaignsCreated.length} campaigns for ${checkParam}`,
      campaignsGenerated: campaignsCreated.length,
      campaigns: campaignsCreated,
      healthDaysChecked: healthDays.map((d) => d.name),
      triggeredBy: request.headers.get("x-vercel-cron") ? "cron" : "manual",
    })
  } catch (error: any) {
    console.error("auto-campaigns generate error:", error)
    
    // Log failed execution to Firestore
    try {
      const ok = initAdmin()
      if (ok) {
        const db = admin.firestore()
        const url = new URL(request.url)
        const checkParam = url.searchParams.get("check") || "today"
        
        await db.collection("cron_logs").add({
          executedAt: admin.firestore.FieldValue.serverTimestamp(),
          checkParam,
          success: false,
          campaignsGenerated: 0,
          error: error?.message || "Failed to generate campaigns",
          triggeredBy: request.headers.get("x-vercel-cron") ? "cron" : "manual",
        })
      }
    } catch (logError) {
      console.error("Error logging failed cron execution:", logError)
      // Don't fail the request if logging fails
    }

    return NextResponse.json(
      {
        success: false,
        error: error?.message || "Failed to generate campaigns",
      },
      { status: 500 }
    )
  }
}

/**
 * POST /api/auto-campaigns/generate
 * Body: { check?: "today" | "tomorrow", publish?: boolean, sendWhatsApp?: boolean }
 */
export async function POST(request: Request) {
  try {
    const body = await request.json().catch(() => ({}))
    const check = body.check || "today"
    const publish = body.publish !== false
    const sendWhatsApp = body.sendWhatsApp === true

    // Create a new request URL with query params
    const url = new URL(request.url)
    url.searchParams.set("check", check)
    url.searchParams.set("publish", String(publish))
    url.searchParams.set("sendWhatsApp", String(sendWhatsApp))

    // Call GET handler with modified URL
    return GET(new Request(url.toString()))
  } catch (error: any) {
    console.error("auto-campaigns generate POST error:", error)
    return NextResponse.json(
      {
        success: false,
        error: error?.message || "Failed to generate campaigns",
      },
      { status: 500 }
    )
  }
}

